# RFC
### 1. Executive summary
Компанія Company.Inc – стартап, який займається питаннями екології та збереження навколишнього середовища.
### 2. Project overview
Наразі компанія займається розробкою системи моніторингу екології, яка буде збирати інформацію про стан навколишнього середовища та матиме можливість передавати їх в контролюючі органи.

### 3. Ключові аспекти системи:
	o Integration: інтеграція з існуючими системами екологічного контролю
	o Flexibility: система повинна підтримувати велику кількість різноманітних датчиків для збору показників
	o Performance: система повинна підтримувати високу частоту оновлення даних з багатьох пристроїв та зберігати велику кількість даних для подальшого використання

### 3. Requirements
3.1.1 Інтерфейс
Система повинна мати зручний інтерфейс для перегляду даних про стан навколишнього середивища, та детальну інфографіку з основними показниками.
#### 3.1.2 Підтримувані пристрої
#### Система повинна підтримувати велику кількість різних пристроїв для збору інформації:
	- датчики хімічного складу повітря
	- газоаналізатори
	- датчики хімічного складу грунту
	- датчики якості води
	- детектори нафтопродуктів
#### 3.1.3 Public API
Система повинна реалізовувати публічний API для того щоб будь-хто бажаючий міг отримати дані в зручному форматі.
#### 3.1.4 Експорт даних
Система повинна мати можливість експортувати дані в різних форматах, а також можливість генерації звітів на надсилання їх в контролюючі органи. 

# Список використаних технологій
**Архітектурний дизайн:** Модульний моноліт з  Event-driven підходом

**Основна мова програмування:**  C# with ASP.NET
**Front-End частина:** JavaScript with Angular 

**API:** RESTful 
**Протокол:** HTTPS
**Документація:** OpenAPI

**База даних:** Apache Cassandra (NoSQL)
**Резервне копіювання бази даних:** Apache Cassandra's nodetool

**Middleware:**
**Потокова передача даних:** Apache Kafka
**Кешування:** Redis (TTL)
**Інтеграція з датчиками та сенсорами:** Azure IoT Hub 
**Протокол:** MQTT
**Оновлення в реальному часі:** SignalR for ASP.NET 

**Безпека:**
**Шифрування даних:** TLS, AES
**Керування ідентифікацією та доступом:** Keycloak 
**Протокол автентифікації та авторизації користувача:** OAuth 2.0

**CI/CD:** Jenkins 

**Інструменти моніторингу:** Prometheus

# C4
## Context diagram
<img width="1137" alt="Page" src="https://github.com/Alaska2222/C4-modular-monolith-with-EDA/assets/100542322/185eefc9-dfa6-4304-9be0-f207c94b1024">

## Container diagram
<img width="1650" alt="Page_1" src="https://github.com/Alaska2222/C4-modular-monolith-with-EDA/assets/100542322/f7a4c6ff-21cd-4e10-aab9-48d172ef73b0">

### 1) Зовнішні датчики та пристрої збору даних про навколишнє середовище:
Перелік всіх пристроїв: 
- датчики хімічного складу повітря Aeroqual Series 200, 300, 500
	- газоаналізатори MultiRAE Series
	- датчики хімічного складу грунту Decagon Devices 5TE
	- датчики якості води YSI ProDSS (Digital Sampling System)
	- детектори нафтопродуктів InfraCal TOG/TPH Analyzers
Вони відповідають за збір екологічних даних та є асинхронно надсилають дані до IoT Service.

### 2) Сервіс Інтернету речей (Azure IoT Hub):
Цей сервіс діє як посередник між зовнішніми датчиками та рештою системи. Він отримує дані, надіслані через протокол MQTT від датчиків. Потім публікує їх як події та надсилає до Event Processor.

### 3) Event Processor (Apache Kafka, SignalR):
Цей контейнер діє як центральна платформа потокової передачі подій. 
Він підписується на події, опубліковані сервісом IoT. Отримавши дані, процесор подій може виконувати обробку даних у реальному часі та надсилати сповіщення підписаним клієнтам через SignalR.

### 4) API Application (C# ASP.NET):
Це серверна частина програми написана на C# ASP.NET. Вона взаємодіє з процесором подій для отримання оброблених даних, обробляє всю логіку, маніпулує даними та подає оброблені дані до front-end частини. Також виконує операції читання та запису з базою даних.

### 5) База даних (Apache Cassandra):
Ця NoSQL база даних зберігає всі дані, оброблені через API Application.

### 6) SPA:
Це графічний інтерфейс програми написаний на JavaScript і Angular.
Він здійснює виклики API до серверної частини через HTTPS протокол для отримання або надсилання даних. Також надає дані користувачам в інтерактивній та зручній формі.

### 7) Сервіс моніторингу (Prometheus):
Цей 3rd party service використовується системним адміністратором та технічним інженером для отримання метрик для моніторингу системи.
Також взаємодіє з процесором подій і API Application для збору даних про продуктивність.

## Component diagram
<img width="2158" alt="Page_2" src="https://github.com/Alaska2222/C4-modular-monolith-with-EDA/assets/100542322/cf3ff185-afab-4667-a847-6f122140e1b9">

### Користувачі (Users): 
Різні типи користувачів (дослідник, кінцевий користувач, адміністратор системи, технічний інженер), які взаємодіють з системою через GUI або API. Кожен тип користувача має свій рівень доступу та можливості.

### Зовнішні сенсори та пристрої (External Sensors and Devices):
Вони включають датчики якості повітря, води, ґрунту та нафтопродуктів, які надсилають дані до системи.

### SPA (Single Page Application):
Реалізоване з використанням JavaScript і Angular, слугує як інтерфейс користувача (GUI).

### Модуль безпеки (Security Module):
Цей компонент відповідає за безпеку, автентифікацію, авторизацію та шифрування даних.

### Модуль обробки даних (Data Processing Module):
Виконує прийом даних, їх фільтрацію, агрегацію та відсилання подій в інші модулі.

### Модуль потокової передачі даних (Event Processor):
Використовує Apache Kafka, SignalR для обробки подій у реальному часі, що дозволяє системі швидко реагувати на зміни.

### Модуль кешування (Caching Module):
Зберігає часто запитувані дані для швидкого доступу, використовуючи паттерн Time-to-Live, Redis.

### Модуль резервного копіювання та відновлення даних (Data Backup & Recovery Module):
Забезпечує відновлення системи після збоїв, дотримуючись встановлених цілей часу відновлення (RTO/RPO).

### База даних (Database Module):
Використовує Apache Cassandra для зберігання даних, включаючи історію даних користувачів, системних подій та агрегованих даних.

### Логіка роботи системи :
	•Датчики збирають дані про навколишнє середовище та надсилають їх до системи через IoT сервіси та моніторингові служби.
	•Модуль обробки даних приймає вхідні дані, обробляє їх та публікує події, які потім споживаються модулем потокової передачі даних.
	•Дані кешуються для швидкого доступу та зберігаються у базі даних для історичного аналізу та звітності.
	•Користувачі взаємодіють з системою через веб-додаток, де вони можуть переглядати дані та отримувати звіти.
	•Модуль безпеки забезпечує захист даних та керування доступом користувачів.
	•У разі збою, модуль резервного копіювання та відновлення забезпечує відновлення системи, використовуючи збережені резервні копії даних.

## Class diagram
![pLRTJkCy4BtFK_YE8b8Uu1Eg-DHTgIiLWMXv03UP9DvrxCXs2kpFk-_4SSmaflVBLNtcp9pv6JlSMyUDwrkPNR6jvDQo4YgXX1DQsQpmo9ON3JnmnMimx5V6y6_D39J2RgK0vTX_xFdZ5Eo5Tm9dH66Hi2N7m92wne1es_iV0OKpnZZq9riOSG9Z1xkmxkxh7D-mA_P_NHke-P0gWpVUTX9y](https://github.com/Alaska2222/C4-modular-monolith-with-EDA/assets/100542322/af3413d7-67f8-4ad4-a207-45206e93bc3d)

### CacheManager
Призначення: керує кешуванням даних.

### Поля: 
	• redisClient: екземпляр RedisClient, який використовується для взаємодії з системою кешування Redis.
	• cacheMetrics: екземпляр CacheMetrics, який використовується для відстеження показників продуктивності кешу, таких як hits та misses.
	• logger: екземпляр Logger, який використовується для реєстрації дій і помилок, пов’язаних з операціями кешу. 
### Методи:
	• initializeCache(): ініціалізує систему кешування.
	• set(key, value, ttl): зберігає значення в кеші з специфікою патерну time-to-live (ttl).
	• get(key): Отримує значення з кешу.
	• delete(ключ): Видаляє значення з кешу.
	• exists(key): Перевіряє наявність ключа в кеші.
	• subscribeToEvents(): підписується на події, пов’язані з кеш-пам’яттю.
 
### RedisClient
Призначення: безпосередньо взаємодіє з базою даних Redis, забезпечуючи рівень абстракції над операціями Redis.

### Поля:
	•configuration: параметри конфігурації для підключення до Redis.
	•ConnectionPool: керує підключеннями Redis.
	•eventSubscriber: обробляє підписки на події, пов’язані з Redis

### Методи:
	•connect(): встановлює з’єднання з Redis.
	•disconnect(): закриває з’єднання з Redis.
	•public(channel, message), subscribe(channel), unsubscribe(channel): методи для функціональності Pub/Sub у Redis.

### Configuration
Призначення: Зберігає деталі конфігурації для підключення Redis.

### Поля: 
	•host:  Вказує на ім’я хоста або IP-адресу сервера Redis.
	•port: Представляє номер порту, на якому працює сервер Redis.
	•password: Пароля, необхідний для доступу до сервера Redis.
	•useSSL: Вказує, чи використовувати для з’єднання шифрування SSL.
	•connectionTimeout: Представляє тривалість тайм-ауту для з’єднання в мілісекундах.

### Методи:
	•Configuration(host, port, password, useSSL, connectionTimeout): конструктор, який ініціалізує новий екземпляр класу конфігурації з наданими параметрами.
	•getHost(): повертає ім’я хоста або IP-адресу сервера Redis.
	•getPort(): повертає номер порту, на якому працює сервер Redis.
	•getPassword(): повертає пароль, необхідний для доступу до сервера Redis.
	•isUseSSL(): повертає логічне значення, яке вказує, чи ввімкнено шифрування SSL для з’єднання.
	•getConnectionTimeout(): повертає тривалість тайм-ауту з’єднання в мілісекундах.

### ConnectionPool
Призначення: керує пулом підключень Redis для оптимізації використання ресурсів і продуктивності.

### Поля:
	•maxTotal: Представляє максимальну загальну кількість активних з’єднань, які можуть бути виділені з цього пулу одночасно.
	•maxIdle: Представляє максимальну кількість підключень, які можуть залишатися неактивними в пулі, без звільнення додаткових.
	•minIdle: Вказує на мінімальну кількість неактивних підключень, які пул намагається підтримувати.

### Методи:
	•getConnection(): отримує об’єкт RedisConnection із пулу, створюючи новий, якщо це необхідно.
	•releaseConnection(connection): повертає об’єкт RedisConnection назад до пулу, роблячи його доступним для повторного використання.

### EventSubscriber(клас) та EventHandler(інтерфейс)
Призначення: EventSubscriber керує підписками на різні події, а EventHandler є інтерфейсом для обробки цих подій.

### Поля: 
	•subscribedEvents: Map<String, List<EventHandler>>, де кожен ключ є типом події, а значенням є список об’єктів EventHandler, які обробляють цей тип події.

### Методи:
	•subscribe(eventType: String, handler: EventHandler): підписує даний обробник на вказаний тип події.
	•unsubscribe(eventType: String): скасовує підписку на всі обробники вказаного типу події.
	•onEvent(event: Event): викликається, коли відбувається подія; він надсилає подію всім зареєстрованим обробникам для цього типу події.

### Event
Призначення: представляє подію в системі, наприклад потрапляння в кеш або промах.

### Поля:
	•type: тип події
	•payload: дані, пов’язані з подією.

### CacheMetrics
Призначення: відстежує та звітує про показники продуктивності кешу.

### Поля:
	•hitCount: int, що відстежує кількість успішних операцій із кешу.
	•missCount: int, що відстежує кількість невдалих спроб отримання кешу.
	•totalLoadTime: long, що представляє загальний час, потрібний для завантаження елементів у кеш.
	•totalRetrievalTime: long, що представляє загальний час, витрачений на всі операції пошуку кешу.

### Методи:
	•recordHit(): збільшує hitCount кожного разу, коли відбувається звернення до кешу.
	•recordMiss(): збільшує missCount кожного разу, коли відбувається промах кешу.
	•CalculateHitRate(): обчислює показник звернень як відношення звернень до загальної кількості запитів (звернення + промахи).
	•reportMetrics(): компілює та повертає звіт про показники продуктивності кешу.

### Logger
Призначення: забезпечує функцію журналювання для системи.

### Методи:
	•log(message: String): записує загальне повідомлення.
	•error(message: String): записує повідомлення про помилку, яке зазвичай використовується для обробки помилок.
	•info(message: String): записує інформаційне повідомлення, яке часто використовується для регулярних операцій або змін стану.

# Testing Scope
## Функціональне тестування
#### •Модуль безпеки:
Тестування механізмів шифрування (TLS, AES), правильності функціонування процесів авторизації та автентифікації, враховуючи різні рівні доступу.

#### •Модуль кешування: 
Тестування правильності роботи системи кешування, враховуючи особливості Redis та патерну TTL.

#### •Модуль бази даних:
Тестування моделей даних, CQL запитів та інших аспектів БД.

#### •Модуть інтерфейсу(SPA):
Тестування фронт-енд частини.

#### •Модуль обробки даних:
Тестування коректності оброблення вхідних даних, обробку агрегованих даних.

#### •Експорт даних і створення звітів:
Тестування здатності системи експортувати дані в різних форматах (CSV, Excel, PDF, JSON) і на їх основі створювати 	звіти.

#### •Ролі користувачів:
Тестування різних ролей (системний адміністратор, дослідник, технічний інженер, кінцевий користувач) та їхні конкретні функції.

#### •Інтеграція:
Тестування інтеграції із зовнішніми датчиками та пристроями для збору даних та 3rd party сервісами IoT Azure Hub, Prometheus. Також 	тестування інтеграції між різними системними компонентами та модулями.

#### •API:
Tестування API.

## Нефункціональне тестування
#### •Продуктивність та час відгуку:
Тестування часу відгуку системи при нормальному та піковому навантаженні, перевірка чи вони співпадають з визначеними 	вимогами.
#### •Сумісність та відповідність:
Тестування роботи системи на різних браузерах (Chrome, Opera, Firefox, Microsoft Edge), та відповідності системи екологічним стандартам(ISO 14001:2015, EU Environmental Directives) та стандартам конфіденційності(GDPR).
#### •Recovery & Backup:
Тестування здатності системи відновлюватися після збоїв і помилок, перевіряючи цільовий час відновлення RTO (4 години) і цільову точку 	відновлення RPO (1 година).
#### •Синхронізація:
Тестування синхронізації даних кожні 15 хвилин, включаючи умови для початку синхронізації та здатність системи зберігати синхронізовані 	дані протягом 24 годин.
#### •UI/UX:
Тестування зручності використання та інтуїтивності користувацького інтерфейсу.

## Test Approaches
Враховуючи вимоги та особливості дизайну мого проекту,  я виділила низку основних підходів тестування, які  на мою думну найкраще підходять у контексті моєї роботи:
### 1)Combined Testing Approach (Manual and Automated)

Комбінація мануального та автоматизованого тестування забезпечує повне покриття всіх аспектів системи, від функціональності до користувацького інтерфейсу. Автоматизація виконує повторювані та часомісткі завдання, тоді як мануальне тестування зосереджується на складних та нюансованих аспектах. Також, автоматизоване тестування швидко виявляє помилки, особливо після змін у коді, тоді як мануальне тестування гарантує глибину аналізу. Цей підхід можна легко адаптувати та масштабувати з урахуванням росту та розвитку мого проекту.

### 2)Scenario-Based Testing

Моя система включає різноманітні компоненти, такі як датчики навколишнього середовища, бази даних, інтерфейси користувача та інтеграцію з зовнішніми системами. Сценарійне тестування дозволяє оцінити, як ці компоненти взаємодіють у реальних умовах використання. Також оскільки моя система має бути зручною і інтуїтивно зрозумілою для різних користувачів, сценарійне тестування допомаже переконатися, що користувацький інтерфейс та функціонал відповідають очікуванням і потребам кінцевих користувачів. Цей підхід може допомогти визначити, як система веде себе у випадках нестандартного або неочікуваного використання, які можуть виникати в реальному світі.

### 3)Analytical Testing Approach

Аналітичний тестовий заснований на детальному аналізі специфікацій системи та ризиків. Цей підхід дозволяє точно визначити області, які потребують найбільшої уваги, оптимізувати ресурси тестування та забезпечити високу якість продукту. Він допомагає зосередитися на критичних аспектах системи, включаючи безпеку, продуктивність та сумісність, тим самим забезпечуючи ефективне виявлення та вирішення потенційних проблем, перш ніж вони стануть критичними.

### 4)Regression Testing Approach

Регресійний тестовий підхід забезпечує, що оновлення або зміни в системі не порушують існуючу функціональність. Цей підхід допомагає підтримувати стабільність системи та запобігати непередбаченим помилкам, що є критичним при роботі з комплексними системами моніторингу. Регресійне тестування дозволяє впевнено впроваджувати нові оновлення, забезпечуючи при цьому надійність і точність роботи системи.

## Test Levels
##### 1.Unit Testing: 
Тестування індивідуальних компонентів та модулів системи на найнижчому рівні. Це включає перевірку окремих функцій, методів та класів для виявлення помилок на ранніх стадіях розробки. 
##### 2.Integration Testing(Non-incremental): 
Перевірка взаємодії між різними модулями системи та 3rd party сервісами. Важливо для забезпечення правильної 	взаємодії компонентів, особливо коли вони об'єднуються для виконання складніших завдань. Non-incremental, оскільки потік даних є складним і складно класифікувати батьків і дітей.
##### 3.System Testing: 
У цьому типі тестування ми перевіряємо кожен атрибут програмного забезпечення та чи кінцева система працює відповідно до бізнес-вимог. 	Це по суті аналіз програмного продукту як цілісної системи.
##### 4.Acceptance Testing: 
Це фінальний етап тестування програми перед публічним запуском, що виконується на підставі набору тестових кейсів і сценаріїв, 		розроблених на підставі вимог до проекту.

## Test Types
![test](https://github.com/Alaska2222/C4-modular-monolith-with-EDA/assets/100542322/7861dbf9-ac93-4eb8-af20-4073727292d7)
### Manual Testing
	•Functional Testing: Оцінка функцій та можливостей системи. Його мета переконатися, що система виконує всі свої функції згідно з визначеними вимогами та специфікаціями. Включатиме ручне тестування процесів авторизації та автентифікації, використання та доступу різних ролей користувачів.
	•Integration Testing: Для зовнішніх датчиків краще я використовуватиму ручне тестування, особливо для перевірки фізичних з'єднань та інтерфейсів.
	•Non-functional Testing: 
	•Usabillity Testing:Ручне тестування зручності використання та інтуїтивності користувацького інтерфейсу дозволить оцінити реальний користувацький досвід, оскільки автомитизоване не завжди може адекватно відтворити взаємодію користувача з інтерфейсом.
	•Compatibility Testing: Тестуватиму складні випадки, де потрібно оцінити відповідність стандартам ISO 14001:2015, EU Environmental Directives, GDPR.

### Automated Testing
	•Functional Testing: До автоматизованого функційного тестування буд належати перевірка: API, кешування, моделей даних та CQL запитів(модуль БД), окремих аспектів модулю інтерфейсу, такі як функціональність кнопок або навігації, модуля обробки даних, експорту та створення звітів, та інших функцій 		системи, які не передбачені при ручному тестуванні.
	•Integration Testing (Non-Incremental): Інтеграція з внутрішніми компонентами та 3rd party сервісами. Неінкрементне тому, що у моїй системі потік даних є складним і дуже складно класифікувати компоненти на parent та child.
	•Non-Functional Testing: 
	•Compatibility Testing: Перевірка сумісності з браузерами: Chrome, Opera, Firefox, Microsoft Edge.
	•Security Testing: Перевірка механізмів шифрування TLS, AES.
	•Performance Testing: Перевірка продуктивності системи та часу її відгуку під різними навантаженнями. Включатиме тестування здатності системи 		відновлюватися після збоїв для перевірки RTO та RPO та тести на синхронізацію.
	•Regression Testing: Тести, які перевіряють, чи впливають останні зміни в коді на вже наявну функціональність.

## Метрики тестування
Метрики оцінювання тестування допомагають визначити якість тестування і виявити можливі проблеми в процесі тестування. 
#### 1. Code coverage: Покриття коду має бути не менше 90% для юніт-тестів, 85% для функціональних та інтеграційних тестів.
#### 2. Defect Discovery Time: Міряє середній час, необхідний для виявлення дефекту після його введення в систему. Ця метрика допомагає оцінити ефективність процесу раннього виявлення помилок. Виявлення 90% дефектів протягом перших 48 годин після їх введення в код.
#### 3. Defect Fix Rate: Відстежує кількість виправлених дефектів протягом певного періоду. Це допомагає оцінити продуктивність та ефективність команди розробників. Виправлення 80% дефектів протягом одного тижня від дати їх виявлення.
#### 4. Defect Response Time: Час від моменту виявлення дефекту до моменту його виправлення. Ця метрика важлива для оцінки швидкості реакції команди на знайдені помилки. Середній час реагування на дефект - менше 24 годин.
#### 5. Test Execution Time: Метрика, що показує оптимізований час виконання тестів. Середній час виконання всіх тестів: < 30 хвилин.
Максимальний час виконання для критичних тестових сценаріїв: < 10 хвилин.

## Інструменти Тестування
### Usability Testing:
Tools: Інструмент для збору зворотного зв'язку від користувачів, UserTesting

### Compatibility Testing:
Tools: Selenium для доступу до різних платформ.

### Functional Testing:
Tools: Selenium (для автоматизації веб-інтерфейсу), NUnit(для юніт-тестування в C#), Postman (для API тестування).

### Security Testing:
Tools: OWASP ZAP для тестування веб-безпеки, а також вбудовані інструменти безпеки в Keycloak та OAuth 2.0.
Tools for TLS/AES Testing: Для тестування шифруванн OpenSSL.

### Performance Testing:
Tools: Apache JMeter  для тестування продуктивності

### Regression Testing:
Tools: Уже наявні Selenium для автоматизації веб-інтерфейсу, NUnit або xUnit для юніт-тестування. Ці тести можна інтегрувати в CI/CD процес за допомогою Jenkins.

### Cashing testing:
Tools: Redis

### Модуль бази даних:
Tools: Тестування моделей даних та CQL запитів може бути виконано за допомогою Apache Cassandra’s cqlsh 

### Recovery & Backup:
Tools: Apache Cassandra's nodetool для тестування резервного копіювання та відновлення.

### Синхронізація:
Tools: Автоматизація тестування синхронізації може бути виконана за допомогою інтеграції з Apache Kafka.

