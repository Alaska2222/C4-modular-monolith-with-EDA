# RFC
### 1. Executive summary
Компанія Company.Inc – стартап, який займається питаннями екології та збереження навколишнього середовища.
### 2. Project overview
Наразі компанія займається розробкою системи моніторингу екології, яка буде збирати інформацію про стан навколишнього середовища та матиме можливість передавати їх в контролюючі органи.

### 3. Ключові аспекти системи:
	o Integration: інтеграція з існуючими системами екологічного контролю
	o Flexibility: система повинна підтримувати велику кількість різноманітних датчиків для збору показників
	o Performance: система повинна підтримувати високу частоту оновлення даних з багатьох пристроїв та зберігати велику кількість даних для подальшого використання

### 3. Requirements
3.1.1 Інтерфейс
Система повинна мати зручний інтерфейс для перегляду даних про стан навколишнього середивища, та детальну інфографіку з основними показниками.
#### 3.1.2 Підтримувані пристрої
#### Система повинна підтримувати велику кількість різних пристроїв для збору інформації:
	- датчики хімічного складу повітря
	- газоаналізатори
	- датчики хімічного складу грунту
	- датчики якості води
	- детектори нафтопродуктів
#### 3.1.3 Public API
Система повинна реалізовувати публічний API для того щоб будь-хто бажаючий міг отримати дані в зручному форматі.
#### 3.1.4 Експорт даних
Система повинна мати можливість експортувати дані в різних форматах, а також можливість генерації звітів на надсилання їх в контролюючі органи. 

# Список використаних технологій
**Архітектурний дизайн:** Модульний моноліт з  Event-driven підходом

**Основна мова програмування:**  C# with ASP.NET
**Front-End частина:** JavaScript with Angular 

**API:** RESTful 
**Протокол:** HTTPS
**Документація:** OpenAPI

**База даних:** Apache Cassandra (NoSQL)
**Резервне копіювання бази даних:** Apache Cassandra's nodetool

**Middleware:**
**Потокова передача даних:** Apache Kafka
**Кешування:** Redis (TTL)
**Інтеграція з датчиками та сенсорами:** Azure IoT Hub 
**Протокол:** MQTT
**Оновлення в реальному часі:** SignalR for ASP.NET 

**Безпека:**
**Шифрування даних:** TLS, AES
**Керування ідентифікацією та доступом:** Keycloak 
**Протокол автентифікації та авторизації користувача:** OAuth 2.0

**CI/CD:** Jenkins 

**Інструменти моніторингу:** Prometheus

# C4
## Context diagram
<img width="1137" alt="Page" src="https://github.com/Alaska2222/C4-modular-monolith-with-EDA/assets/100542322/185eefc9-dfa6-4304-9be0-f207c94b1024">

## Container diagram
<img width="1650" alt="Page_1" src="https://github.com/Alaska2222/C4-modular-monolith-with-EDA/assets/100542322/f7a4c6ff-21cd-4e10-aab9-48d172ef73b0">

### 1) Зовнішні датчики та пристрої збору даних про навколишнє середовище:
Перелік всіх пристроїв: 
- датчики хімічного складу повітря Aeroqual Series 200, 300, 500
	- газоаналізатори MultiRAE Series
	- датчики хімічного складу грунту Decagon Devices 5TE
	- датчики якості води YSI ProDSS (Digital Sampling System)
	- детектори нафтопродуктів InfraCal TOG/TPH Analyzers
Вони відповідають за збір екологічних даних та є асинхронно надсилають дані до IoT Service.

### 2) Сервіс Інтернету речей (Azure IoT Hub):
Цей сервіс діє як посередник між зовнішніми датчиками та рештою системи. Він отримує дані, надіслані через протокол MQTT від датчиків. Потім публікує їх як події та надсилає до Event Processor.

### 3) Event Processor (Apache Kafka, SignalR):
Цей контейнер діє як центральна платформа потокової передачі подій. 
Він підписується на події, опубліковані сервісом IoT. Отримавши дані, процесор подій може виконувати обробку даних у реальному часі та надсилати сповіщення підписаним клієнтам через SignalR.

### 4) API Application (C# ASP.NET):
Це серверна частина програми написана на C# ASP.NET. Вона взаємодіє з процесором подій для отримання оброблених даних, обробляє всю логіку, маніпулує даними та подає оброблені дані до front-end частини. Також виконує операції читання та запису з базою даних.

### 5) База даних (Apache Cassandra):
Ця NoSQL база даних зберігає всі дані, оброблені через API Application.

### 6) SPA:
Це графічний інтерфейс програми написаний на JavaScript і Angular.
Він здійснює виклики API до серверної частини через HTTPS протокол для отримання або надсилання даних. Також надає дані користувачам в інтерактивній та зручній формі.

### 7) Сервіс моніторингу (Prometheus):
Цей 3rd party service використовується системним адміністратором та технічним інженером для отримання метрик для моніторингу системи.
Також взаємодіє з процесором подій і API Application для збору даних про продуктивність.

## Component diagram
<img width="2158" alt="Page_2" src="https://github.com/Alaska2222/C4-modular-monolith-with-EDA/assets/100542322/cf3ff185-afab-4667-a847-6f122140e1b9">

### Користувачі (Users): 
Різні типи користувачів (дослідник, кінцевий користувач, адміністратор системи, технічний інженер), які взаємодіють з системою через GUI або API. Кожен тип користувача має свій рівень доступу та можливості.

### Зовнішні сенсори та пристрої (External Sensors and Devices):
Вони включають датчики якості повітря, води, ґрунту та нафтопродуктів, які надсилають дані до системи.

### SPA (Single Page Application):
Реалізоване з використанням JavaScript і Angular, слугує як інтерфейс користувача (GUI).

### Модуль безпеки (Security Module):
Цей компонент відповідає за безпеку, автентифікацію, авторизацію та шифрування даних.

### Модуль обробки даних (Data Processing Module):
Виконує прийом даних, їх фільтрацію, агрегацію та відсилання подій в інші модулі.

### Модуль потокової передачі даних (Event Processor):
Використовує Apache Kafka, SignalR для обробки подій у реальному часі, що дозволяє системі швидко реагувати на зміни.

### Модуль кешування (Caching Module):
Зберігає часто запитувані дані для швидкого доступу, використовуючи паттерн Time-to-Live, Redis.

### Модуль резервного копіювання та відновлення даних (Data Backup & Recovery Module):
Забезпечує відновлення системи після збоїв, дотримуючись встановлених цілей часу відновлення (RTO/RPO).

### База даних (Database Module):
Використовує Apache Cassandra для зберігання даних, включаючи історію даних користувачів, системних подій та агрегованих даних.

### Логіка роботи системи :
	•Датчики збирають дані про навколишнє середовище та надсилають їх до системи через IoT сервіси та моніторингові служби.
	•Модуль обробки даних приймає вхідні дані, обробляє їх та публікує події, які потім споживаються модулем потокової передачі даних.
	•Дані кешуються для швидкого доступу та зберігаються у базі даних для історичного аналізу та звітності.
	•Користувачі взаємодіють з системою через веб-додаток, де вони можуть переглядати дані та отримувати звіти.
	•Модуль безпеки забезпечує захист даних та керування доступом користувачів.
	•У разі збою, модуль резервного копіювання та відновлення забезпечує відновлення системи, використовуючи збережені резервні копії даних.

## Class diagram
![pLRTJkCy4BtFK_YE8b8Uu1Eg-DHTgIiLWMXv03UP9DvrxCXs2kpFk-_4SSmaflVBLNtcp9pv6JlSMyUDwrkPNR6jvDQo4YgXX1DQsQpmo9ON3JnmnMimx5V6y6_D39J2RgK0vTX_xFdZ5Eo5Tm9dH66Hi2N7m92wne1es_iV0OKpnZZq9riOSG9Z1xkmxkxh7D-mA_P_NHke-P0gWpVUTX9y](https://github.com/Alaska2222/C4-modular-monolith-with-EDA/assets/100542322/af3413d7-67f8-4ad4-a207-45206e93bc3d)

### CacheManager
Призначення: керує кешуванням даних.

### Поля: 
	• redisClient: екземпляр RedisClient, який використовується для взаємодії з системою кешування Redis.
	• cacheMetrics: екземпляр CacheMetrics, який використовується для відстеження показників продуктивності кешу, таких як hits та misses.
	• logger: екземпляр Logger, який використовується для реєстрації дій і помилок, пов’язаних з операціями кешу. 
### Методи:
	• initializeCache(): ініціалізує систему кешування.
	• set(key, value, ttl): зберігає значення в кеші з специфікою патерну time-to-live (ttl).
	• get(key): Отримує значення з кешу.
	• delete(ключ): Видаляє значення з кешу.
	• exists(key): Перевіряє наявність ключа в кеші.
	• subscribeToEvents(): підписується на події, пов’язані з кеш-пам’яттю.
 
### RedisClient
Призначення: безпосередньо взаємодіє з базою даних Redis, забезпечуючи рівень абстракції над операціями Redis.

### Поля:
	•configuration: параметри конфігурації для підключення до Redis.
	•ConnectionPool: керує підключеннями Redis.
	•eventSubscriber: обробляє підписки на події, пов’язані з Redis

### Методи:
	•connect(): встановлює з’єднання з Redis.
	•disconnect(): закриває з’єднання з Redis.
	•public(channel, message), subscribe(channel), unsubscribe(channel): методи для функціональності Pub/Sub у Redis.

### Configuration
Призначення: Зберігає деталі конфігурації для підключення Redis.

### Поля: 
	•host:  Вказує на ім’я хоста або IP-адресу сервера Redis.
	•port: Представляє номер порту, на якому працює сервер Redis.
	•password: Пароля, необхідний для доступу до сервера Redis.
	•useSSL: Вказує, чи використовувати для з’єднання шифрування SSL.
	•connectionTimeout: Представляє тривалість тайм-ауту для з’єднання в мілісекундах.

### Методи:
	•Configuration(host, port, password, useSSL, connectionTimeout): конструктор, який ініціалізує новий екземпляр класу конфігурації з наданими параметрами.
	•getHost(): повертає ім’я хоста або IP-адресу сервера Redis.
	•getPort(): повертає номер порту, на якому працює сервер Redis.
	•getPassword(): повертає пароль, необхідний для доступу до сервера Redis.
	•isUseSSL(): повертає логічне значення, яке вказує, чи ввімкнено шифрування SSL для з’єднання.
	•getConnectionTimeout(): повертає тривалість тайм-ауту з’єднання в мілісекундах.

### ConnectionPool
Призначення: керує пулом підключень Redis для оптимізації використання ресурсів і продуктивності.

### Поля:
	•maxTotal: Представляє максимальну загальну кількість активних з’єднань, які можуть бути виділені з цього пулу одночасно.
	•maxIdle: Представляє максимальну кількість підключень, які можуть залишатися неактивними в пулі, без звільнення додаткових.
	•minIdle: Вказує на мінімальну кількість неактивних підключень, які пул намагається підтримувати.

### Методи:
	•getConnection(): отримує об’єкт RedisConnection із пулу, створюючи новий, якщо це необхідно.
	•releaseConnection(connection): повертає об’єкт RedisConnection назад до пулу, роблячи його доступним для повторного використання.

### EventSubscriber(клас) та EventHandler(інтерфейс)
Призначення: EventSubscriber керує підписками на різні події, а EventHandler є інтерфейсом для обробки цих подій.

### Поля: 
	•subscribedEvents: Map<String, List<EventHandler>>, де кожен ключ є типом події, а значенням є список об’єктів EventHandler, які обробляють цей тип події.

### Методи:
	•subscribe(eventType: String, handler: EventHandler): підписує даний обробник на вказаний тип події.
	•unsubscribe(eventType: String): скасовує підписку на всі обробники вказаного типу події.
	•onEvent(event: Event): викликається, коли відбувається подія; він надсилає подію всім зареєстрованим обробникам для цього типу події.

### Event
Призначення: представляє подію в системі, наприклад потрапляння в кеш або промах.

### Поля:
	•type: тип події
	•payload: дані, пов’язані з подією.

### CacheMetrics
Призначення: відстежує та звітує про показники продуктивності кешу.

### Поля:
	•hitCount: int, що відстежує кількість успішних операцій із кешу.
	•missCount: int, що відстежує кількість невдалих спроб отримання кешу.
	•totalLoadTime: long, що представляє загальний час, потрібний для завантаження елементів у кеш.
	•totalRetrievalTime: long, що представляє загальний час, витрачений на всі операції пошуку кешу.

### Методи:
	•recordHit(): збільшує hitCount кожного разу, коли відбувається звернення до кешу.
	•recordMiss(): збільшує missCount кожного разу, коли відбувається промах кешу.
	•CalculateHitRate(): обчислює показник звернень як відношення звернень до загальної кількості запитів (звернення + промахи).
	•reportMetrics(): компілює та повертає звіт про показники продуктивності кешу.

### Logger
Призначення: забезпечує функцію журналювання для системи.

### Методи:
	•log(message: String): записує загальне повідомлення.
	•error(message: String): записує повідомлення про помилку, яке зазвичай використовується для обробки помилок.
	•info(message: String): записує інформаційне повідомлення, яке часто використовується для регулярних операцій або змін стану.

